<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.1//EN"
"http://www.oasis-open.org/docbook/xml/simple/1.1/sdocbook.dtd">
<article>
  <articleinfo>
    <title>LensKit Design Document</title>

    <author>
      <firstname>Michael</firstname>

      <surname>Ekstrand</surname>

      <affiliation>
        <orgname>University of Minnesota</orgname>
      </affiliation>
    </author>

    <pubdate>March 29, 2011</pubdate>
  </articleinfo>

  <note>
    <para>This document is out-of-date. Its contents will eventually be
    refactored into multiple design and usage guides.</para>
  </note>

  <section id="sec-design-goals">
    <title>Design Goals</title>

    <para>LensKit's design is driven by three primary goals:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Clarity.</emphasis> LensKit should embody a clean,
        straightforward but not naïve implementation of a recommender system
        based on several algorithms.</para>
      </listitem>

      <listitem id="goal-modularity">
        <para><emphasis>Modularity.</emphasis> LensKit's architecture and
        algorithm implementations should be flexible and reconfigurable so
        that new algorithm configurations can be assembled from the pieces of
        existing algorithms. Algorithm pieces, such as normalizers and
        similarity functions, should be loosely coupled so that they can be
        reused with other algorithms.</para>
      </listitem>

      <listitem>
        <para><emphasis>Efficiency.</emphasis> LensKit should be efficient,
        capable of running on significant data sets with reasonable hardware
        requirements. Efficiency should not, however, come at the expense of
        readability.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section id="sec-decisions">
    <title>High-Level Design Decisions</title>

    <para>This section documents several high-level design and technology
    selection decisions for the LensKit architecture and code base.</para>

    <section id="sec-java-platform">
      <title>Java Platform</title>

      <para>LensKit is implemented in Java 1.6. Several reasons contributed to
      our selection of Java as the implementation language and
      platform.</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Approachability.</emphasis> Java is a widely-known
          language, so a Java implementation will be understandable by a large
          number of programmers and students. Implementing in Java allows the
          code to be usable in a variety of educational settings and opens it
          to use and extension by students, researchers, and other software
          developers.</para>
        </listitem>

        <listitem>
          <para><emphasis>Performance.</emphasis> The Java virtual machine has
          a high-quality optimizing compiler, allowing us to achieve good
          performance with straightforward code if we take some care in our
          choice of data structures and code structure.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="sec-fastutil">
      <title>Primitive Collections — Fastutil</title>

      <para>Java's data model does not allow generic types, such as data
      structures, to be parameterized over primitive types. Therefore code
      wishing to store primitive types in collections must first box them into
      the corresponding object types. For a package like LensKit which makes
      extensive use of large collections of longs, doubles, and other
      primitives, this boxing exacts a significant penalty both in memory use
      and execution time as the memory allocator and garbage collector must
      work noticably harder. We use the <ulink
      url="http://fastutil.dsi.unimi.it/">Fastutil</ulink> library of
      primitive collections extensively to be able to use high-level data
      structures, such as sets, maps, and lists, without the memory and
      performance penalty of boxing most numbers. This allows us to achieve
      good performance without using and managing arrays directly all the
      time.</para>

      <para>There are several primitive collection libraries around, such as
      PCJ and GNU Trove. We selected Fastutil because it supports generics
      where appropriate and takes advantage of Java 5 features to provide a
      clean API. Further, Fastutil classes implement the relevant Java
      Collections interfaces so it is easy to integrate with code written
      against the Java Collections API.</para>

      <para>While Fastutil is used internally extensively, the APIs are
      designed so that client code that only wants to use LensKit for
      recommendation is not required to use Fastutil to interface with
      recommenders and predictors. This also makes it easier to integrate
      LensKit with other APIs that produce standard Java collections. When
      collection objects are a Fastutil collection, however, the
      implementations generally take advantage of that and avoid temporary
      boxing.</para>

      <para>We have also written some new primitive collection classes and
      utilities. Some provide complete new primitive collections like
      Fastutil's implementation does (such as <literal>
      LongArraySortedSet</literal>), while others are entirely new data
      structures (like <literal>SparseVector</literal>).</para>
    </section>

    <section id="sec-strategy">
      <title>Strategy Pattern</title>

      <para>In LensKit, we often encounter situations where there are several
      approaches to a particular piece of code. One example of this is the
      method for filling in the item-item similarity matrix for item-based
      collaborative filtering: if the similarity function is symmetric, we can
      loop over a triangular section of the matrix and treat item pairs as
      unordered, while an asymmetric simialrity function requires considering
      item pairs as ordered and iterating over the entire matrix. Another
      example is in user-user collaborative filtering ― the high-level
      structure is always the same (find neighbors, then aggregate), but
      different neighborhood-finding strategies are possible.</para>

      <para>There are a couple of ways of implementing this effect:</para>

      <itemizedlist>
        <listitem>
          <para>Create an abstract class containing the common logic and put
          the replacable logic in an abstract method to be implemented in
          derived classes for the various strategies.</para>
        </listitem>

        <listitem>
          <para>Use the <ulink
          url="http://en.wikipedia.org/wiki/Strategy_pattern"><emphasis>strategy
          pattern</emphasis></ulink>, a design pattern in which the replacable
          code is defined via an interface, with the different strategies
          implementing that interface. The interface is then used via
          composition in class implementing the common logic.</para>
        </listitem>
      </itemizedlist>

      <para>In LensKit, we prefer the strategy pattern. Composing strategies
      works very well with dependency injection as the user-user recommender
      can simply depend on the neighborhood-finding strategy. It also makes
      the code more explicit at the call site, as it is clear that the method
      implementing the strategy resides elsewhere and is pluggable, as opposed
      to an abstract method where the method's declaration must be consulted
      to see that it is intended to be overridden.</para>

      <para>The current LensKit code is not yet consistent in its use of this
      choice, but we are working on making it more so. Additionally, this
      design decision is not a hard-and-fast rule. If it clearly makes more
      sense to use inheritance than composition for a particular class,
      readability and understandability should trump inordinate
      consistency.</para>
    </section>

    <section id="sec-logging">
      <title>Logging Framework — SLF4J</title>

      <para>In LensKit, we use the <ulink url="http://www.slf4j.org"> Simple
      Logging Facade for Java (<acronym>SLF4J</acronym>)</ulink> logging
      framework. This allows LensKit to emit log messages independent of the
      actual logging library used in the surrounding code. It can be cleanly
      integrated with applications using Log4J, standard Java logging, Jakarta
      Commons logging, or Logback. Applications included with LensKit use
      <ulink url="http://logback.qos.ch/">Logback</ulink> as the logging
      backend.</para>
    </section>

    <section id="sec-maven">
      <title>Build and Dependency Management — Maven</title>

      <para>LensKit uses <ulink url="http://maven.apache.org">Apache
      Maven</ulink> as its build system. This provides full dependency
      management in the build system, so we do not need to include library
      JARs in our version control or maintain them (and their dependencies)
      ourself. It also makes it easy to use LensKit in other projects, as
      Maven automatically fetches the appropriate version of LensKit from the
      Maven central repositories — all that a client application needs to do
      is declare a dependency on the LensKit packages it uses in its Maven POM
      file.</para>

      <para>Maven does come with some additional complexity, and can at times
      be difficult to configure. Basic projects, however, can be created and
      managed very easily. Additionally, LensKit can be easily used in
      projects built with Ant by using <ulink
      url="http://ant.apache.org/ivy/">Ivy</ulink>, a dependency management
      extension to Ant that can load dependencies from Maven
      repositories.</para>

      <para>Maven also provides us with a unified framework for handling
      project reporting and building the project web site with integrated
      JavaDoc, hyperlinked source code, and reports such as package
      dependencies, software licenses, and static code analysis.</para>
    </section>
  </section>

  <section>
    <title>API Design</title>

    <para>LensKit provides a common API for all recommender implementations,
    allowing the recommender algorithm for an application to be replaced with
    minimal need to modify the application's code.</para>

    <section>
      <title>Basic Data Model</title>

      <para>In order to do recommendations, we need standard representations
      for the basic entities in the recommender: users, items, and ratings or
      occurrances. In selecting representations, we want to balance genericity
      with efficiency. Allowing users and items to be arbitrary types, either
      deriving from base <literal role="class">User</literal> or <literal
      role="class"> Item</literal> classes or as generic type parameters,
      would allow a great deal of flexibility. This requires objects for every
      user or item, however, and if users and items are integers then this can
      impose significant overhead due to unnecessary boxing and
      indirection.</para>

      <para>In LensKit, we have opted to uniformly use <literal
      role="type">long</literal> IDs for users and items. No restrictions are
      placed on these IDs. Ratings are represented via the <literal
      role="class">Rating</literal> interface, which exposes the user ID, item
      ID, rating as a double, and optional timestamp. In some parts of the
      API, we use sparse vectors mapping item (or user) IDs to ratings to
      represent user (or item) rating vectors.</para>

      <para>Sparse vectors are realized through our custom <literal
      role="class">SparseVector</literal> interface and its subclass <literal
      role="class">MutableSparseVector</literal>. SparseVector is an efficient
      mapping from longs to doubles that uses parallel primitive arrays sorted
      by key and binary search. Dot products can be computed very efficiently
      by iterating over two arrays in parallel. The class also memoizes the
      sum, mean, and L2 norm so that they can be accessed efficiently.
      MutableSparseVector extends the sparse vector by allowing values (but
      not keys) to be modified, allowing efficient in-place addition,
      subtraction, and scaling of vectors.</para>
    </section>

    <section>
      <title>Recommendation API</title>

      <para>The recommendation API in LensKit is broken into separate pieces
      to allow different types of access and reflect the fact that not all
      recommendation methods support all types of recommendation. The <literal
      role="class">Recommender</literal> interface is the primary entry point
      for using a recommender. It provides access to different recommender
      operations are supported by the following interfaces:</para>

      <itemizedlist>
        <listitem>
          <para><literal role="class">RatingPredictor</literal> supports the
          <emphasis>predict</emphasis> task, allowing client code to query for
          the predicted value of a user's rating.</para>
        </listitem>

        <listitem>
          <para><literal role="class">DynamicRatingPredictor</literal>
          supports the predict task for users whose ratings are provided at
          call time rather than retrieved from the backing data store.</para>
        </listitem>

        <listitem>
          <para><literal role="class">ItemRecommender</literal> supports the
          <emphasis>recommend</emphasis> task where users have expressed
          ratings, allowing client code to query for recommendations based on
          a user's ID.</para>
        </listitem>

        <listitem>
          <para><literal role="class">DynamicItemRecommender</literal>
          supports the recommend task with user IDs provided at recommendation
          time.</para>
        </listitem>
      </itemizedlist>

      <para>Recommender operations are typically lightweight objects that wrap
      an implementation-specific recommender model, which in turn contains all
      the configuration and persistent data for the recommender.</para>
    </section>

    <section>
      <title>Building Recommenders</title>

      <para><literal role="class">Recommender</literal>s are obtained by
      "opening" them from recommender engines (the <literal
      role="class">RecommenderEngine</literal> interface). Before
      recommendation or prediction can be done, the program needs a
      recommender engine. Recommender services are built using <literal
      role="class">RecommenderServiceBuilder</literal> instances. Each
      recommender implementation will provide a recommender service builder
      that knows how to build it from its constituent components. Service
      builders provide getters and setters to configure the various parameters
      used by a particular recommender and a <literal
      role="class">build(RatingBuildContext)</literal> method that actually
      builds the recommender. The basic procedure for setting up a recommender
      is as follows:</para>

      <orderedlist>
        <listitem>
          <para>Construct and configure the appropriate recommender model
          builder.</para>
        </listitem>

        <listitem>
          <para>Set up a rating data access object (see <link
          linkend="sec-data-access">Data Access Layer</link>).</para>
        </listitem>

        <listitem>
          <para>Create a build context from the data acces object.</para>
        </listitem>

        <listitem>
          <para>Pass the build context to the builder and get a recommender
          model.</para>
        </listitem>

        <listitem>
          <para>Create one or more recommender operations built on the model,
          or wrap the model up with operation factories in a <literal
          role="class">RecommenderService</literal> to make it easily
          available throughout the application.</para>
        </listitem>
      </orderedlist>

      <para>Many recommenders will have subcomponents that also need to be
      built from a build context. For this purpose, the <literal
      role="class">RecommenderComponentBuilder&lt;T&gt;</literal> interface is
      provided. Builders take build contexts and produce objects. They also
      memoize their results, so calling the build method twice with the same
      build context will produce the same object. The memoization facility
      does impose the limitation that a builder instance cannot be
      reconfigured and used to build a second object from the same rating
      build context.</para>

      <para>This design will allow recommender services to be flexibly
      configured. Further, since many Java scripting languages support easy
      access to Bean properties, it will be possible to configure recommenders
      with scripts in JavaScript or other Java-compatible scripting languages
      that look much like configuration files: a sequence of parameter
      assignments with the occasional object construction.</para>

      <para>Builder objects are also fully composable: builders can use other
      builders to build subcomponents of their target objects, allowing
      recommender components to be nested and configured almost arbitrarily.
      Configuration code will need to take care to use the same builder
      instance when the same type of object is needed in multiple places to
      avoid unnecessarily duplicating objects, but this will hopefully not
      impose an unreasonable burden.</para>
    </section>

    <section id="sec-data-access">
      <title>Data Access Layer</title>

      <para>In order to build recommender models and provide recommendations,
      LensKit needs an API for obtaining rating or purchase data from data
      sources. Further, this API needs to be generic and flexible so that the
      recommenders can be integrated into a variety of environments. Some
      recommenders may also need to respond to rating data changes to update
      or invalidate caches. Finally, while pre-computing recommender models it
      can be necessary to iterate over the ratings data multiple times without
      it changing in the process, necessitating a means for isolating rating
      data reads.</para>

      <para>To solve these problems, we have designed a rating API with two
      primary components. The core part of the data access layer is modeled
      after the J2EE <ulink
      url="http://java.sun.com/blueprints/corej2eepatterns/Patterns/DataAccessObject.html">Data
      Access Object</ulink> pattern. The <literal>
      UserItemDataAccessObject</literal> interface provides accesss to users
      and items, while the <literal> RatingDataAccessObject</literal>
      interface makes rating data available. These interfaces are intended to
      be implemented by singletons, so all code across an application uses the
      same data access object (and thus any object can register a listener to
      receive notifications of rating updates).</para>

      <para>Actual data access is mediated via cursor objects implementing the
      <literal>Cursor</literal> interface. A cursor is essentially an iterator
      that can be closed and may be able to report its size. This allows
      backing resources, such as files or database result sets, to be
      closed.</para>

      <para>Cursors must exist in sessions. <literal
      role="class">RatingDataAccessObject</literal> provides <literal
      role="method">openSession()</literal> and <literal
      role="method">closeSession()</literal> methods which open and close the
      active session on a particular thread. Requesting a cursor without an
      active session is an error. Client code is responsible for making sure
      that all recommender access occurs within a session; servlet filters or
      Struts interceptors are a good place to make sure this happens. Data
      access object implementations should use thread-local storage to allow
      each thread to have its own session.</para>

      <para>In addition to data data access objects, we also have a concept of
      <emphasis>build contexts</emphasis>, realized through the
      <literal>RatingBuildContext</literal> interface. A build context is a
      snapshot of the ratings data at a particular point in time, suitable for
      repeated iteration to learn a recommender model. It also captures
      characteristics such as the number of users and items and provides a
      mapping from user and item IDs to consecutive zero-based integers
      suitable for array indexing. Further, the collection of ratings it
      captures supports a concept borrwed from Fastutil called <emphasis>fast
      iteration</emphasis>, where an iterator mutates a single object in-place
      and returns it again rather than creating a new object for each
      <literal> next()</literal> call. This allows large collections of
      synthetic objects to be iterated more efficiently when the objects are
      not needed outside the iterating loop body. Rating build contexts also
      have a type-safe object storage facility using unique keys to allow
      builders to store memoized objects on the build context rather than
      internally; this allows intermediate objects to be more easily garbage
      collected once the build process has finished.</para>

      <para>The primary build context implementation, <literal
      role="class">PackedRatingBuildContext</literal>, simply iterates over
      all ratings presented by the data access object and stores the rating
      data efficiently in a set of parallel arrays, allowing for very fast
      iteration.</para>

      <para>This collection of interfaces allows LensKit to have access to the
      data, provides a mechanism for applications to notify LensKit components
      of rating updates, and stable snapshots for iterative model
      building.</para>
    </section>

    <section>
      <title>Vectors</title>

      <para>There are many places in recommender implementation where it is
      useful to have sparse vectors (vectors where many of the values are
      missing). To support these needs, LensKit includes a sparse vector
      implementation in the <literal
      role="package">org.grouplens.lenskit.data.vector</literal> package.
      Sparse vectors are stored in parallel arrays sorted by <literal
      role="type">long</literal> key. This allows efficient access to specific
      values, and also allows binary operations such as dot products to be
      computed efficiently with a single linear pass through the arrays
      backing two vectors. It also provides a place to memoize single-vector
      metrics such as sum and L2 norm.</para>

      <para>The key sets of a sparse vector is immutable once the vector has
      been created. This can be limiting, but it allows the implementation
      code to be very simple and works out well in practice. A common pattern
      is to accumulate values for a new vector in a fastutil hash table and
      then convert it to a vector for subsequent operations.</para>

      <para>The <literal role="class">MutableSparseVector</literal> class
      provides a sparse vector which supports in-place mutation of values.
      This allows vector addition, subtraction, and scaling to be handled
      efficiently without incurring excess copying overhead. It does require
      client code to occasionally create additional vectors, but it allows the
      client code to control how many copies are made and potentially re-use
      vectors.</para>

      <para>Since sparse vectors can be mutated, we wanted a way to declare
      methods so that a sparse vector that might be mutated later cannot be
      passed to certain methods which may store the vector somewhere. We
      therefore developed the following three-prong type family for sparse
      vectors:</para>

      <itemizedlist>
        <listitem>
          <para><literal role="class">SparseVector</literal> provides a
          read-only view of a sparse vector. Objects of this type cannot be
          modified; however, since <literal
          role="class">MutableSparseVector</literal> is a subclass of <literal
          role="class">SparseVector</literal>, other code may know the
          object's real type and mutate it.</para>
        </listitem>

        <listitem>
          <para><literal role="class">MutableSparseVector</literal> is a
          mutable sparse vector, as discussed above.</para>
        </listitem>

        <listitem>
          <para><literal role="class">ImmutableSparseVector</literal> is a
          read-only sparse vector that is guaranteed not to change. If an
          object or method receives an immutable sparse vector, it can safely
          save it and know that no other code will change it. Immutable sparse
          vectors are also thread-safe (and are the only sparse vectors that
          can be safely shared across thread boundaries).</para>
        </listitem>
      </itemizedlist>

      <para>The SparseVector class provides methods to convert to an
      appropriate type of vector, avoiding copying when making an
      already-immutable sparse vector immutable. Since the key set is
      immutable, conversions requiring a copy only need to copy the value
      array. Future work may allow the value array to also be shared by making
      mutable sparse vectors copy-on-write.</para>
    </section>
  </section>

  <section>
    <title id="sec-algorithms">Algorithm Implementation Design</title>

    <para>Different recommender algorithms require specific design
    considerations. This section documents those for the various algorithms
    implemented in LensKit.</para>

    <section>
      <title id="sec-normalization">Normalization</title>

      <para>In keeping with LensKit's modular design, normalization is
      considered to be a cross-cutting concern orthoganal to the recommender
      algorithm employed.</para>

      <para>Currently, the only supported normalization is baseline
      subtraction, where the real recommender algorithm is supplied with a
      baseline predictor and the prediction for each rating is subtracted from
      the rating prior to processing. In the predict phase, the baseline is
      added back to the predictions before returning them.</para>

      <para>We are planning to add support for more flexibile normalization
      strategies, so that baseline normalization is only one, but have not yet
      figured out how we want to do that. It is being tracked in <ulink
      url="http://dev.grouplens.org/trac/lenskit/ticket/31">bug
      #31</ulink>.</para>
    </section>

    <section>
      <title id="sec-user-cf">User-User Collaborative Filtering</title>

      <para>Algorithmically, user-user CF divides into three
      components:</para>

      <orderedlist>
        <listitem>
          <para>Find user neighborhoods for items under consideration. For
          recommendation, this may also involve finding the items which can
          have neighborhoods.</para>
        </listitem>

        <listitem>
          <para>Compute predicted preferences for items.</para>
        </listitem>

        <listitem>
          <para>Generate recommendation list.</para>
        </listitem>
      </orderedlist>

      <para>The predict task, of course, only involves steps 1 and 2. It is
      possible to combine one or more of the steps into a single loop, but we
      separate them in order to allow them to be reconfigured
      separately.</para>

      <para>The class <literal
      role="class">UserUserRatingRecommender</literal> implements the <literal
      role="class">RatingRecommender</literal> and <literal
      role="class">RatingPredictor</literal> interfaces, embodying the code
      for steps 2 and 3. It depends in turn on a <literal
      role="class">NeighborhoodFinder</literal>, providing the
      neighborhood-finding logic required for step 1. NeighborhoodFinder's
      interface follows:</para>

      <programlisting language="java">/**
 * Interface for neighborhood-finding strategies. These strategies are used by
 * {@link UserUserRatingRecommender} to find neighbors for recommendation.
 * @author Michael Ekstrand &lt;ekstrand@cs.umn.edu&gt;
 *
 */
public interface NeighborhoodFinder {
    /**
     * Find neighboring users for particular items.
     * @param user The user ID.
     * @param ratings The user rating vector.
     * @param items The items we're trying to recommend, or &lt;tt&gt;null&lt;/tt&gt; to get
     * get neighborhoods for all possible items.
     * @return A map from item IDs to user neighborhoods for all items for which
     * we can find neighboring users.
     */
    
    Long2ObjectMap&lt;? extends Collection&lt;Neighbor&gt;&gt; findNeighbors(long user,
            @Nonnull SparseVector ratings, @Nullable LongSet items);
}</programlisting>

      <para>The <literal role="method">findNeighbors</literal> method finds
      collections of neighbors by whatever means are appropriate. The <literal
      role="class">Neighbor</literal> class contains the neighbor's user ID,
      rating vector, and its similarity to the user in question. The specific
      neighborhood finder implementation is responsible for using the
      similarity function to identify neighbors and truncate the neighborhood
      lists as appropriate. This allows the neighborhood strategy to be
      implemented and selected entirely independently of the rating
      aggregation logic. There are two neighborhood strategies currently
      provided with LensKit:</para>

      <itemizedlist>
        <listitem>
          <para><literal role="class">SimpleNeighborhoodFinder</literal> uses
          a similarity function, represented by an instance of <literal
          role="class">Similarity&lt;SparseVector&gt;</literal>, and scans
          over all the user profiles in the database to find the most similar
          users. It does no caching and is therefore fairly
          inefficient.</para>
        </listitem>

        <listitem>
          <para><literal role="class">CachingNeighborhoodFinder</literal>
          caches user rating vectors in memory, indexed by the items they
          contain. This allows the neighborhoods to be determined more quickly
          by only considering users who have co-rated movies with the user in
          question. It requires that the similarity function is
          <emphasis>optimizable</emphasis>, or always returns 0 for two rating
          vectors with disjoint item sets. Optimizable similarities implement
          the <literal role="class">OptimizableVectorSimilarity</literal>
          interface.</para>
        </listitem>
      </itemizedlist>

      <para>Currently, the rating aggregation strategy — weighted averaging —
      is hard-coded into <literal
      role="class">UserUserRatingRecommender</literal>. At present, other
      rating aggregation strategies are rarely used. It would be a relatively
      simple matter to factor it out into another strategy interface, however,
      if we want to be able to experiment with alternative strategies. At
      present, if someone wants to change it, they can re-implement or
      subclass the existing implementation.</para>
    </section>

    <section>
      <title id="sec-item-cf">Item-Item Collaborative Filtering</title>

      <para>Item-item CF is divided somewhat differently, as it uses a
      pre-built model. It is therefore divided into separate classes as
      follows:</para>

      <itemizedlist>
        <listitem>
          <para><literal role="class">ItemItemModel</literal> contains the
          item-item similarity matrix and neighborhood-finding code.
          Currently, the neighborhood-finding strategy is fixed, but this can
          be changed.</para>
        </listitem>

        <listitem>
          <para><literal role="class">ItemItemModelBuilder</literal> uses a
          <literal role="class">BuildContext</literal> and a normalizing
          baseline to build a new Item-item model. It normalizes and
          transposes the rating matrix (generating a set of item rating
          vectors), then hands it off to an <literal
          role="class">ItemItemModelBuildStrategy</literal> to compute the
          actual similarity matrix.</para>
        </listitem>

        <listitem>
          <para><literal role="class">ItemItemModelBuildStrategy</literal>
          abstracts the process of computing an item-item similarity matrix
          from a transposed ratings matrix. The exact strategy depends on what
          can be assumed about the similarity function:</para>

          <itemizedlist>
            <listitem>
              <para>The naive method, implemented by <literal
              role="class">SimpleModelBuildStrategy</literal>, computes the
              pairwise similarity between all pairs of items. It makes no
              assumptions about the nature of the similarity function but may
              compute many unnecessary similarities.</para>
            </listitem>

            <listitem>
              <para>If the similarity function is symmetric (indicated by
              implementing the <literal
              role="class">SymmetricBinaryFunction</literal> tag interfac),
              then the builder only needs to compute one triangle of the
              matrix. The algorithm is still O(n^2), but avoids half the
              similarity computations. <literal
              role="class">SymmetricModelBuildStrategy</literal> handles this
              case.</para>
            </listitem>

            <listitem>
              <para>If the similarity function is optimizable, then only items
              that have been rated by the same users need to be compared. With
              the help of some additional bookkeeping data recorded during the
              initial matrix transposition, this results in substantial
              efficiency gains. <literal
              role="class">SparseModelBuildStrategy</literal> implements this
              approach.</para>
            </listitem>

            <listitem>
              <para>Finally, <literal
              role="class">SparseSymmetricModelBuildStrategy</literal> handles
              similarity functions which are both optimizable and
              symmetric.</para>
            </listitem>
          </itemizedlist>

          <para><literal
          role="class">ItemItemModelBuildStrategyProvider</literal> is the
          default means of providing build strategies for injection and
          automatically selects the appropriate strategy based on the type of
          the similarity function. This can be overridden by re-binding
          <literal role="class">ItemItemModelBuildStrategy</literal> in a
          Guice module.</para>
        </listitem>

        <listitem>
          <para><literal role="class">ItemItemModelProvider</literal>
          implements a Guice <literal role="class">Provider</literal> that
          depends on a build context and baseline and uses the <literal
          role="class">ItemItemModelBuilder</literal> to provide a model a
          new. It is the default provider for <literal
          role="class">ItemItemModel</literal> (using a
          <literal>ProvidedBy</literal> annotation). It is also the extension
          point for replacing the <literal
          role="class">ItemItemModelBuilder</literal>; customizers can bind
          <literal role="class">ItemItemModel</literal> to a different class
          or provider to replace it and/or the model builder entirely.</para>
        </listitem>

        <listitem>
          <para><literal role="class">ItemItemRatingPredictor</literal> wraps
          an <literal role="class">ItemItemModel</literal> and provides the
          rating prediction service. It also exposes the model, but this
          feature is not for public use.</para>
        </listitem>

        <listitem>
          <para><literal role="class">ItemItemRatingRecommender</literal>
          takes an <literal role="class">ItemItemRatingPredictor</literal>,
          with its exposed model, and provides a rating recommender built on
          it. Rating recommendation is done in two passes: first the
          recommendable items are collected (if the client has not provided a
          candidate list), and then prediction is done. This allows
          recommendations to be accumulated in sparse vectors rather than hash
          tables and reduces data conversion overhead.</para>
        </listitem>

        <listitem>
          <para><literal role="class">SimilarityMatrixBuilder</literal>
          abstracts building similarity matrices. It exposes <literal
          role="method">put</literal> methods for putting similarities in the
          matrix and a <literal role="class">build</literal> method that
          compiles the accumulated similarities into an (usually truncated)
          immutable matrix. The similarity matrix builder itself is split into
          multiple stages:</para>

          <orderedlist>
            <listitem>
              <para>Use a <literal
              role="class">SimilarityMatrixBuilderFactory</literal> to get a
              <literal role="class">SimilarityMatrixBuilder</literal> that
              will build a matrix for a given number of rows. This is
              necessary so the matrix builder can know the matrix size ahead
              of time.</para>
            </listitem>

            <listitem>
              <para>Accumulate similarities in the <literal
              role="class">SimilarityMatrixBuilder</literal>.</para>
            </listitem>

            <listitem>
              <para>Call the matrix builder's build() method to get a <literal
              role="class">SimilarityMatrix</literal>.</para>
            </listitem>
          </orderedlist>

          <para>The default (and currently only) implementation of the
          similarity matrix framework is TruncatingSimilarityMatrixBuilder,
          which accumulates and maintains the truncated rows of the similarity
          matrix in priority queues. For a neighborhood size N, the matrix
          builder only ever keeps the N most similar neighbors of each item in
          memory.</para>
        </listitem>
      </itemizedlist>

      <para>This level of division and declarative dependency structure allows
      the item-item recommender to be extensively reconfigured and customized.
      It should therefore be fairly easy to plug a new piece into it to test
      new recommender ideas.</para>
    </section>

    <section>
      <title>Singular Value Decomposition</title>

      <para>LensKit also provides a recommender (currently only implementing
      the <literal role="class">RatingPredictor</literal> interface) built on
      singular value decomposition.</para>

      <para>The architecture of the SVD recommender is similar to but simpler
      than the item-item CF implementation. Instead of having a single builder
      class that uses pluggable strategies, it has an <literal
      role="class">SVDModelBuilder</literal> interface that takes the build
      context and baseline and builds an <literal
      role="class">SVDModel</literal>. This is used by <literal
      role="class">SVDModelProvider</literal> to provide models to Guice. This
      difference is due to the increased dissimilarity between SVD
      impelmentations; as we implement additional SVD algorithms, we may
      consolidate code and introduce an additional strategy interface.</para>

      <para>Currently there is a single SVD model builder, <literal
      role="grade">GradientDescentSVDModelBuilder</literal>. It implements a
      gradient descent approximation approach to SVD; configured with an
      appropriately damped baseline, it becomes FunkSVD.</para>
    </section>
  </section>
</article>
