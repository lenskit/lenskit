<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.1//EN"
"http://www.oasis-open.org/docbook/xml/simple/1.1/sdocbook.dtd">
<article>
  <articleinfo>
    <title>LensKit Design Document</title>

    <author>
      <firstname>Michael</firstname>

      <surname>Ekstrand</surname>

      <affiliation>
        <orgname>University of Minnesota</orgname>
      </affiliation>
    </author>

    <pubdate>March 29, 2011</pubdate>
  </articleinfo>

  <section id="sec-design-goals">
    <title>Design Goals</title>

    <para>LensKit's design is driven by three primary goals:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Clarity.</emphasis> LensKit should embody a clean,
        straightforward but not naïve implementation of a recommender system
        based on several algorithms.</para>
      </listitem>

      <listitem id="goal-modularity">
        <para><emphasis>Modularity.</emphasis> LensKit's architecture and
        algorithm implementations should be flexible and reconfigurable so
        that new algorithm configurations can be assembled from the pieces of
        existing algorithms. Algorithm pieces, such as normalizers and
        similarity functions, should be loosely coupled so that they can be
        reused with other algorithms.</para>
      </listitem>

      <listitem>
        <para><emphasis>Efficiency.</emphasis> LensKit should be efficient,
        capable of running on significant data sets with reasonable hardware
        requirements. Efficiency should not, however, come at the expense of
        readability.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section id="sec-decisions">
    <title>High-Level Design Decisions</title>

    <para>This section documents several high-level design and technology
    selection decisions for the LensKit architecture and code base.</para>

    <section id="sec-java-platform">
      <title>Java Platform</title>

      <para>LensKit is implemented in Java 1.6. Several reasons contributed to
      our selection of Java as the implementation language and
      platform.</para>

      <itemizedlist>
        <listitem>
          <para><emphasis>Approachability.</emphasis> Java is a widely-known
          language, so a Java implementation will be understandable by a large
          number of programmers and students. Implementing in Java allows the
          code to be usable in a variety of educational settings and opens it
          to use and extension by students, researchers, and other software
          developers.</para>
        </listitem>

        <listitem>
          <para><emphasis>Performance.</emphasis> The Java virtual machine has
          a high-quality optimizing compiler, allowing us to achieve good
          performance with straightforward code if we take some care in our
          choice of data structures and code structure.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="sec-fastutil">
      <title>Primitive Collections — Fastutil</title>

      <para>Java's data model does not allow generic types, such as data
      structures, to be parameterized over primitive types. Therefore code
      wishing to store primitive types in collections must first box them into
      the corresponding object types. For a package like LensKit which makes
      extensive use of large collections of longs, doubles, and other
      primitives, this boxing exacts a significant penalty both in memory use
      and execution time as the memory allocator and garbage collector must
      work noticably harder. We use the <ulink
      url="http://fastutil.dsi.unimi.it/">Fastutil</ulink> library of
      primitive collections extensively to be able to use high-level data
      structures, such as sets, maps, and lists, without the memory and
      performance penalty of boxing most numbers. This allows us to achieve
      good performance without using and managing arrays directly all the
      time.</para>

      <para>There are several primitive collection libraries around, such as
      PCJ and GNU Trove. We selected Fastutil because it supports generics
      where appropriate and takes advantage of Java 5 features to provide a
      clean API. Further, Fastutil classes implement the relevant Java
      Collections interfaces so it is easy to integrate with code written
      against the Java Collections API.</para>

      <para>While Fastutil is used internally extensively, the APIs are
      designed so that client code that only wants to use LensKit for
      recommendation is not required to use Fastutil to interface with
      recommenders and predictors. This also makes it easier to integrate
      LensKit with other APIs that produce standard Java collections. When
      collection objects are a Fastutil collection, however, the
      implementations generally take advantage of that and avoid temporary
      boxing.</para>

      <para>We have also written some new primitive collection classes and
      utilities. Some provide complete new primitive collections like
      Fastutil's implementation does (such as <literal>
      LongArraySortedSet</literal>), while others are entirely new data
      structures (like <literal>SparseVector</literal>).</para>
    </section>

    <section id="id-dependency-injection">
      <title>Dependency Injection</title>

      <para>In order to make the <link linkend="goal-modularity">
      modularity</link> LensKit intends to achieve useful, we need a mechanism
      for assembling a collection of components to make a complete
      recommender. As an example of the kind of configuration we need to
      achieve, consider the process of building an item-item collaborative
      filtering model. The model builder requires access to the ratings data,
      a similarity function, a normalization strategy, and other parameters
      such as the number of neighbors to retain.</para>

      <para>One solution to this problem is to use constructor parameters. The
      model builder exposes a constructor that requires each of the components
      necessary to be passed in as a parameter. If we want to construct a
      model builder, we can instantiate each of the components and then
      construct a model builder with them. This can get tedious, as each of
      the components may in turn depend on other components, but it is
      possible and quite flexible. It further allows for unit testing, as each
      piece is broken down into subcomponents and stub implementations can be
      easily inserted.</para>

      <para>This technique is a design pattern called <emphasis>dependency
      injection</emphasis>. Each component declares the components it depends
      on by requiring them as constructor parameters. Then, rather than having
      the component itself directly instantiate or access its dependencies, it
      access the objects passed in to its constructor. The code instantiating
      the component is therefore responsible for selecting which
      implementation of its various dependencies are intended to be used. If
      it needs to construct many instances of some dependency, then it can
      declare a depency on a factory or provider object which creates
      instances.</para>

      <para>Dependency injection allows us to have completely reconfigurable
      recommenders, but without some additional assistance it requires a
      complex sequence of setup code to even be able to use a recommender.
      This is where dependency injection frameworks or containers come in.
      These frameworks allow the programmer to configure which implementations
      are to be used to satisfy dependencies on various interfaces and
      abstract classes, handle transitive dependency resolution, and take care
      of all the difficult work in building up trees of objects. After setting
      up the framework with the desired configuration, code then asks the
      framework to give it an instance of the desired object and the framework
      builds the object with all its dependencies.</para>

      <para>We use the <ulink
      url="http://code.google.com/p/google-guice/">Guice</ulink> dependency
      injection framework in LensKit. Guice is a commonly-used framework which
      does its configuration entirely in Java, using a combination of
      annotations and Java configuration classes called
      <emphasis>modules</emphasis>. Annotations let us carefully describe
      dependencies, including making numeric and string parameters
      dependencies to be managed by Guice, and provide defaults for many of
      the extensible aspects of the LensKit architecture. In order to use
      LensKit, then, it is merely necessary to create a Guice module that
      describes the recommender configuration desired. We provide
      reconfigurable default modules for each of the recommender algorithms we
      provide, so using standard algorithms is very easy. LensKit can further
      be entirely reconfigured through more advanced use of Guice.</para>
    </section>

    <section id="sec-strategy">
      <title>Strategy Pattern</title>

      <para>In LensKit, we often encounter situations where there are several
      approaches to a particular piece of code. One example of this is the
      method for filling in the item-item similarity matrix for item-based
      collaborative filtering: if the similarity function is symmetric, we can
      loop over a triangular section of the matrix and treat item pairs as
      unordered, while an asymmetric simialrity function requires considering
      item pairs as ordered and iterating over the entire matrix. Another
      example is in user-user collaborative filtering ― the high-level
      structure is always the same (find neighbors, then aggregate), but
      different neighborhood-finding strategies are possible.</para>

      <para>There are a couple of ways of implementing this effect:</para>

      <itemizedlist>
        <listitem>
          <para>Create an abstract class containing the common logic and put
          the replacable logic in an abstract method to be implemented in
          derived classes for the various strategies.</para>
        </listitem>

        <listitem>
          <para>Use the <ulink
          url="http://en.wikipedia.org/wiki/Strategy_pattern">
          <emphasis>strategy pattern</emphasis></ulink>, a design pattern in
          which the replacable code is defined via an interface, with the
          different strategies implementing that interface. The interface is
          then used via composition in class implementing the common
          logic.</para>
        </listitem>
      </itemizedlist>

      <para>In LensKit, we prefer the strategy pattern. Composing strategies
      works very well with dependency injection as the user-user recommender
      can simply depend on the neighborhood-finding strategy. It also makes
      the code more explicit at the call site, as it is clear that the method
      implementing the strategy resides elsewhere and is pluggable, as opposed
      to an abstract method where the method's declaration must be consulted
      to see that it is intended to be overridden.</para>

      <para>The current LensKit code is not yet consistent in its use of this
      choice, but we are working on making it more so. Additionally, this
      design decision is not a hard-and-fast rule. If it clearly makes more
      sense to use inheritance than composition for a particular class,
      readability and understandability should trump inordinate
      consistency.</para>
    </section>

    <section id="sec-logging">
      <title>Logging Framework — SLF4J</title>

      <para>In LensKit, we use the <ulink url="http://www.slf4j.org"> Simple
      Logging Facade for Java (<acronym>SLF4J</acronym>)</ulink> logging
      framework. This allows LensKit to emit log messages independent of the
      actual logging library used in the surrounding code. It can be cleanly
      integrated with applications using Log4J, standard Java logging, Jakarta
      Commons logging, or Logback. Applications included with LensKit use
      <ulink url="http://logback.qos.ch/">Logback</ulink> as the logging
      backend.</para>
    </section>

    <section id="sec-maven">
      <title>Build and Dependency Management — Maven</title>

      <para>LensKit uses <ulink url="http://maven.apache.org">Apache
      Maven</ulink> as its build system. This provides full dependency
      management in the build system, so we do not need to include library
      JARs in our version control or maintain them (and their dependencies)
      ourself. It also makes it easy to use LensKit in other projects, as
      Maven automatically fetches the appropriate version of LensKit from the
      Maven central repositories — all that a client application needs to do
      is declare a dependency on the LensKit packages it uses in its Maven POM
      file.</para>

      <para>Maven does come with some additional complexity, and can at times
      be difficult to configure. Basic projects, however, can be created and
      managed very easily. Additionally, LensKit can be easily used in
      projects built with Ant by using <ulink
      url="http://ant.apache.org/ivy/">Ivy</ulink>, a dependency management
      extension to Ant that can load dependencies from Maven
      repositories.</para>

      <para>Maven also provides us with a unified framework for handling
      project reporting and building the project web site with integrated
      JavaDoc, hyperlinked source code, and reports such as package
      dependencies, software licenses, and static code analysis.</para>
    </section>
  </section>

  <section>
    <title>API Design</title>

    <para>LensKit provides a common API for all recommender implementations,
    allowing the recommender algorithm for an application to be replaced with
    minimal need to modify the application's code.</para>

    <section>
      <title>Basic Data Model</title>

      <para>In order to do recommendations, we need standard representations
      for the basic entities in the recommender: users, items, and ratings or
      occurrances. In selecting representations, we want to balance genericity
      with efficiency. Allowing users and items to be arbitrary types, either
      deriving from base <literal role="class">User</literal> or <literal
      role="class"> Item</literal> classes or as generic type parameters,
      would allow a great deal of flexibility. This requires objects for every
      user or item, however, and if users and items are integers then this can
      impose significant overhead due to unnecessary boxing and
      indirection.</para>

      <para>In LensKit, we have opted to uniformly use <literal
      role="type">long</literal> IDs for users and items. No restrictions are
      placed on these IDs. Ratings are represented via the <literal
      role="class">Rating</literal> interface, which exposes the user ID, item
      ID, rating as a double, and optional timestamp. In some parts of the
      API, we use sparse vectors mapping item (or user) IDs to ratings to
      represent user (or item) rating vectors.</para>

      <para>Sparse vectors are realized through our custom <literal
      role="class">SparseVector</literal> interface and its subclass <literal
      role="class">MutableSparseVector</literal>. SparseVector is an efficient
      mapping from longs to doubles that uses parallel primitive arrays sorted
      by key and binary search. Dot products can be computed very efficiently
      by iterating over two arrays in parallel. The class also memoizes the
      sum, mean, and L2 norm so that they can be accessed efficiently.
      MutableSparseVector extends the sparse vector by allowing values (but
      not keys) to be modified, allowing efficient in-place addition,
      subtraction, and scaling of vectors.</para>
    </section>

    <section>
      <title>Recommendation API</title>

      <para>The recommendation API in LensKit is broken into separate pieces
      to allow different types of access and reflect the fact that not all
      recommendation methods support all types of recommendation. There are
      three primary interfaces in the recommendation API:</para>

      <itemizedlist>
        <listitem>
          <para><literal role="class">RatingPredictor</literal> supports the
          <emphasis>predict</emphasis> task, allowing client code to query for
          the predicted value of a user's rating:</para>

          <programlisting language="java">/**
 * Interface for rating prediction.
 * @author Michael Ekstrand &lt;ekstrand@cs.umn.edu&gt;
 *
 */
@ParametersAreNonnullByDefault
public interface RatingPredictor {
    /**
     * Generate a prediction for a single item.
     * @param user the user ID
     * @param ratings the user's rating history
     * @param item the item for which a prediction is required
     * @return the prediction, or &lt;tt&gt;null&lt;/tt&gt; if no prediction is possible
     */
    @Nullable @CheckForNull
    public ScoredId predict(long user, SparseVector ratings, long item);

    /**
     * Generate predictions for a collection of items.
     * @param user the user ID
     * @param ratings the user's ratings
     * @param items the items for which predictions are desired
     * @return A mapping from item IDs to predicted preference.  This mapping
     * may not contain all requested items.
     */
    @Nonnull
    public SparseVector predict(long user, SparseVector ratings, Collection&lt;Long&gt; items);
}</programlisting>
        </listitem>

        <listitem>
          <para><literal role="class">RatingRecommender</literal> supports the
          <emphasis>recommend</emphasis> task where users have expressed
          ratings, allowing client code to query for recommendations based on
          a user's ID and rating profile.</para>

          <programlisting language="java">/**
 * Recommender recommending items from ratings-based user profiles.
 * @author Michael Ekstrand &lt;ekstrand@cs.umn.edu&gt;
 *
 */
public interface RatingRecommender {
    /**
     * Recommend all possible items for a user. The
     * exclude set is the set of keys in &lt;var&gt;ratings&lt;/var&gt; (so items the user
     * has rated are not recommended).
     * @param user The user ID.
     * @param ratings The user's rating vector.
     * @return The sorted list of scored items.
     * @see #recommend(long, SparseVector, int, Set, Set)
     */
    @Nonnull
    public List&lt;ScoredId&gt; recommend(long user, SparseVector ratings);
    
    /**
     * Recommend up to &lt;var&gt;n&lt;/var&gt; items for a user. The
     * exclude set is the set of keys in &lt;var&gt;ratings&lt;/var&gt; (so items the user
     * has rated are not recommended).
     * @param user The user ID.
     * @param ratings The user's rating vector.
     * @param n The number of recommendations to return.
     * @return The sorted list of scored items.
     * @see #recommend(long, SparseVector, int, Set, Set)
     */
    @Nonnull
    public List&lt;ScoredId&gt; recommend(long user, SparseVector ratings, int n);

    /**
     * Recommend all possible items for a user from a set of candidates.  The
     * exclude set is the set of keys in &lt;var&gt;ratings&lt;/var&gt; (so items the user
     * has rated are not recommended).
     * @param user The user ID.
     * @param ratings The user's rating vector.
     * @param candidates The candidate set (can be null to represent the
     * universe).
     * @return The sorted list of scored items.
     * @see #recommend(long, SparseVector, int, Set, Set)
     */
    @Nonnull
    public List&lt;ScoredId&gt; recommend(long user, SparseVector ratings,
            @Nullable Set&lt;Long&gt; candidates);

    /**
     * Produce a set of recommendations for the user.
     * @param user The user's ID
     * @param ratings The user's ratings
     * @param n The number of ratings to return.  If negative, recommend all
     * possible items.
     * @param candidates A set of candidate items which can be recommended.  If
     * &lt;tt&gt;null&lt;/tt&gt;, the candidate set is considered to contain the universe.
     * @param exclude A set of items to be excluded.  If &lt;tt&gt;null&lt;/tt&gt;, it is
     * considered the empty set.  Exclusions are applied to the candidate set,
     * so the final candidate set is &lt;var&gt;candidates&lt;/var&gt; minus
     * &lt;var&gt;exclude&lt;/var&gt;.
     * @return a list of scored recommendations, sorted in nondecreasing order
     * of score.
     */
    @Nonnull
    public List&lt;ScoredId&gt; recommend(long user, SparseVector ratings, int n,
            @Nullable Set&lt;Long&gt; candidates, @Nullable Set&lt;Long&gt; exclude);
}</programlisting>
        </listitem>

        <listitem>
          <para><literal role="class">BasketRecommender</literal> supports the
          <emphasis>recommend</emphasis> task where user profiles are unary,
          such as purchase history or shopping carts, allowing client code to
          query for recommendations based on a user's ID and shopping basket.
          The basket recommender API has not yet been implemented or used, so
          it may chage as we gain experience with it.</para>

          <programlisting language="java">/**
 * Recommender that provides basket-based recommendations (unary user profiles)
 * @author Michael Ekstrand &lt;ekstrand@cs.umn.edu&gt;
 *
 */
public interface BasketRecommender {
    /**
     * Recommend items for a user with a unary history.
     * @param user the user ID
     * @param basket the items in the user's purchase/visit history
     * @return a list of scored recommendations, sorted in nonincreasing order
     * of score.
     */
    @Nonnull
    List&lt;ScoredId&gt; recommend(long user, Set&lt;Long&gt; basket);
}</programlisting>
        </listitem>
      </itemizedlist>

      <para>Even for recommendation methods that support both basket- and
      rating-based recommendation, it may be necessary to use different
      builders that place different requirements on the data types available
      to build recommenders capable of supporting each recommendation
      form.</para>

      <para>At present, we require client code to obtain the user's profile
      before calling the recommendation API. This may change in the future,
      allowing fo recommendation queries given only a user ID.</para>

      <para>It would also be interesting to consider adding an <literal
      role="class">ItemSimilarity</literal> interface for the find similar
      items task, allowing it to be supported independently of basket-based
      recommendation.</para>
    </section>

    <section id="sec-data-access">
      <title>Data Access Layer</title>

      <para>In order to build recommender models and provide recommendations,
      LensKit needs an API for obtaining rating or purchase data from data
      sources. Further, this API needs to be generic and flexible so that the
      recommenders can be integrated into a variety of environments. Some
      recommenders may also need to respond to rating data changes to update
      or invalidate caches. Finally, while pre-computing recommender models it
      can be necessary to iterate over the ratings data multiple times without
      it changing in the process, necessitating a means for isolating rating
      data reads.</para>

      <para>To solve these problems, we have designed a rating API with two
      primary components. The core part of the data access layer is modeled
      after the J2EE <ulink
      url="http://java.sun.com/blueprints/corej2eepatterns/Patterns/DataAccessObject.html">
      Data Access Object</ulink> pattern. The <literal>
      UserItemDataAccessObject</literal> interface provides accesss to users
      and items, while the <literal> RatingDataAccessObject</literal>
      interface makes rating data available. These interfaces are intended to
      be implemented by singletons, so all code across an application uses the
      same data access object (and thus any object can register a listener to
      receive notifications of rating updates).</para>

      <para>Actual data access is mediated via cursor objects implementing the
      <literal>Cursor</literal> interface. A cursor is essentially an iterator
      that can be closed and may be able to report its size. This allows
      backing resources, such as files or database result sets, to be closed.
      Some care is needed to allow cursors to share database handles,
      particularly in a multithreaded application with a singleton data access
      object, but that is the responsibility of impelmenters and is achievable
      with either Guice's scoping features or a combination of thread-local
      variables and reference counting.</para>

      <para>In addition to data data access objects, we also have a concept of
      <emphasis>build contexts</emphasis>, realized through the
      <literal>RatingBuildContext</literal> interface. A build context is a
      snapshot of the ratings data at a particular point in time, suitable for
      repeated iteration to learn a recommender model. It also captures
      characteristics such as the number of users and items and provides a
      mapping from user and item IDs to consecutive zero-based integers
      suitable for array indexing. Further, the collection of ratings it
      captures supports a concept borrwed from Fastutil called <emphasis>fast
      iteration</emphasis>, where an iterator mutates a single object in-place
      and returns it again rather than creating a new object for each
      <literal> next()</literal> call. This allows large collections of
      synthetic objects to be iterated more efficiently when the objects are
      not needed outside the iterating loop body.</para>

      <para>The default build context simply iterates over all ratings
      presented by the data access object and stores the rating data
      efficiently in a set of parallel arrays, allowing for very fast
      iteration.</para>

      <para>This collection of interfaces allows LensKit to have access to the
      data, provides a mechanism for applications to notify LensKit components
      of rating updates, and stable snapshots for iterative model
      building.</para>
    </section>
  </section>

  <section>
    <title id="sec-algorithms">Algorithm Implementation Design</title>

    <para>Different recommender algorithms require specific design
    considerations. This section documents those for the various algorithms
    implemented in LensKit.</para>

    <section>
      <title id="sec-normalization">Normalization</title>

      <para>In keeping with LensKit's modular design, normalization is
      considered to be a cross-cutting concern orthoganal to the recommender
      algorithm employed.</para>

      <para>Currently, the only supported normalization is baseline
      subtraction, where the real recommender algorithm is supplied with a
      baseline predictor and the prediction for each rating is subtracted from
      the rating prior to processing. In the predict phase, the baseline is
      added back to the predictions before returning them.</para>

      <para>We are planning to add support for more flexibile normalization
      strategies, so that baseline normalization is only one, but have not yet
      figured out how we want to do that. It is being tracked in <ulink
      url="http://dev.grouplens.org/trac/lenskit/ticket/31">bug
      #31</ulink>.</para>
    </section>

    <section>
      <title id="sec-user-cf">User-User Collaborative Filtering</title>

      <para>Algorithmically, user-user CF divides into three
      components:</para>

      <orderedlist>
        <listitem>
          <para>Find user neighborhoods for items under consideration. For
          recommendation, this may also involve finding the items which can
          have neighborhoods.</para>
        </listitem>

        <listitem>
          <para>Compute predicted preferences for items.</para>
        </listitem>

        <listitem>
          <para>Generate recommendation list.</para>
        </listitem>
      </orderedlist>

      <para>The predict task, of course, only involves steps 1 and 2. It is
      possible to combine one or more of the steps into a single loop, but we
      separate them in order to allow them to be reconfigured
      separately.</para>

      <para>The class <literal
      role="class">UserUserRatingRecommender</literal> implements the <literal
      role="class">RatingRecommender</literal> and <literal
      role="class">RatingPredictor</literal> interfaces, embodying the code
      for steps 2 and 3. It depends in turn on a <literal
      role="class">NeighborhoodFinder</literal>, providing the
      neighborhood-finding logic required for step 1. NeighborhoodFinder's
      interface follows:</para>

      <programlisting language="java">/**
 * Interface for neighborhood-finding strategies. These strategies are used by
 * {@link UserUserRatingRecommender} to find neighbors for recommendation.
 * @author Michael Ekstrand &lt;ekstrand@cs.umn.edu&gt;
 *
 */
public interface NeighborhoodFinder {
    /**
     * Find neighboring users for particular items.
     * @param user The user ID.
     * @param ratings The user rating vector.
     * @param items The items we're trying to recommend, or &lt;tt&gt;null&lt;/tt&gt; to get
     * get neighborhoods for all possible items.
     * @return A map from item IDs to user neighborhoods for all items for which
     * we can find neighboring users.
     */
    
    Long2ObjectMap&lt;? extends Collection&lt;Neighbor&gt;&gt; findNeighbors(long user,
            @Nonnull SparseVector ratings, @Nullable LongSet items);
}</programlisting>

      <para>The <literal role="method">findNeighbors</literal> method finds
      collections of neighbors by whatever means are appropriate. The <literal
      role="class">Neighbor</literal> class contains the neighbor's user ID,
      rating vector, and its similarity to the user in question. The specific
      neighborhood finder implementation is responsible for using the
      similarity function to identify neighbors and truncate the neighborhood
      lists as appropriate. This allows the neighborhood strategy to be
      implemented and selected entirely independently of the rating
      aggregation logic. There are two neighborhood strategies currently
      provided with LensKit:</para>

      <itemizedlist>
        <listitem>
          <para><literal role="class">SimpleNeighborhoodFinder</literal> uses
          a similarity function, represented by an instance of <literal
          role="class">Similarity&lt;SparseVector&gt;</literal>, and scans
          over all the user profiles in the database to find the most similar
          users. It does no caching and is therefore fairly
          inefficient.</para>
        </listitem>

        <listitem>
          <para><literal role="class">CachingNeighborhoodFinder</literal>
          caches user rating vectors in memory, indexed by the items they
          contain. This allows the neighborhoods to be determined more quickly
          by only considering users who have co-rated movies with the user in
          question. It requires that the similarity function is
          <emphasis>optimizable</emphasis>, or always returns 0 for two rating
          vectors with disjoint item sets. Optimizable similarities implement
          the <literal role="class">OptimizableVectorSimilarity</literal>
          interface.</para>
        </listitem>
      </itemizedlist>

      <para>Currently, the rating aggregation strategy — weighted averaging —
      is hard-coded into <literal
      role="class">UserUserRatingRecommender</literal>. At present, other
      rating aggregation strategies are rarely used. It would be a relatively
      simple matter to factor it out into another strategy interface, however,
      if we want to be able to experiment with alternative strategies. At
      present, if someone wants to change it, they can re-implement or
      subclass the existing implementation.</para>
    </section>

    <section>
      <title id="sec-item-cf">Item-Item Collaborative Filtering</title>

      <para>Item-item CF is divided somewhat differently, as it uses a
      pre-built model. It is therefore divided into separate classes as
      follows:</para>

      <itemizedlist>
        <listitem>
          <para><literal role="class">ItemItemModel</literal> contains the
          item-item similarity matrix and neighborhood-finding code.
          Currently, the neighborhood-finding strategy is fixed, but this can
          be changed.</para>
        </listitem>

        <listitem>
          <para><literal role="class">ItemItemModelBuilder</literal> uses a
          <literal role="class">BuildContext</literal> and a normalizing
          baseline to build a new Item-item model. It normalizes and
          transposes the rating matrix (generating a set of item rating
          vectors), then hands it off to an <literal
          role="class">ItemItemModelBuildStrategy</literal> to compute the
          actual similarity matrix.</para>
        </listitem>

        <listitem>
          <para><literal role="class">ItemItemModelBuildStrategy</literal>
          abstracts the process of computing an item-item similarity matrix
          from a transposed ratings matrix. The exact strategy depends on what
          can be assumed about the similarity function:</para>

          <itemizedlist>
            <listitem>
              <para>The naive method, implemented by <literal
              role="class">SimpleModelBuildStrategy</literal>, computes the
              pairwise similarity between all pairs of items. It makes no
              assumptions about the nature of the similarity function but may
              compute many unnecessary similarities.</para>
            </listitem>

            <listitem>
              <para>If the similarity function is symmetric (indicated by
              implementing the <literal
              role="class">SymmetricBinaryFunction</literal> tag interface),
              then the builder only needs to compute one triangle of the
              matrix. The algorithm is still O(n^2), but avoids half the
              similarity computations. <literal
              role="class">SymmetricModelBuildStrategy</literal> handles this
              case.</para>
            </listitem>

            <listitem>
              <para>If the similarity function is optimizable, then only items
              that have been rated by the same users need to be compared. With
              the help of some additional bookkeeping data recorded during the
              initial matrix transposition, this results in substantial
              efficiency gains. <literal
              role="class">SparseModelBuildStrategy</literal> implements this
              approach.</para>
            </listitem>

            <listitem>
              <para>Finally, <literal
              role="class">SparseSymmetricModelBuildStrategy</literal> handles
              similarity functions which are both optimizable and
              symmetric.</para>
            </listitem>
          </itemizedlist>

          <para><literal
          role="class">ItemItemModelBuildStrategyProvider</literal> is the
          default means of providing build strategies for injection and
          automatically selects the appropriate strategy based on the type of
          the similarity function. This can be overridden by re-binding
          <literal role="class">ItemItemModelBuildStrategy</literal> in a
          Guice module.</para>
        </listitem>

        <listitem>
          <para><literal role="class">ItemItemModelProvider</literal>
          implements a Guice <literal role="class">Provider</literal> that
          depends on a build context and baseline and uses the <literal
          role="class">ItemItemModelBuilder</literal> to provide a model a
          new. It is the default provider for <literal
          role="class">ItemItemModel</literal> (using a
          <literal>ProvidedBy</literal> annotation). It is also the extension
          point for replacing the <literal
          role="class">ItemItemModelBuilder</literal>; customizers can bind
          <literal role="class">ItemItemModel</literal> to a different class
          or provider to replace it and/or the model builder entirely.</para>
        </listitem>

        <listitem>
          <para><literal role="class">ItemItemRatingPredictor</literal> wraps
          an <literal role="class">ItemItemModel</literal> and provides the
          rating prediction service. It also exposes the model, but this
          feature is not for public use.</para>
        </listitem>

        <listitem>
          <para><literal role="class">ItemItemRatingRecommender</literal>
          takes an <literal role="class">ItemItemRatingPredictor</literal>,
          with its exposed model, and provides a rating recommender built on
          it. Rating recommendation is done in two passes: first the
          recommendable items are collected (if the client has not provided a
          candidate list), and then prediction is done. This allows
          recommendations to be accumulated in sparse vectors rather than hash
          tables and reduces data conversion overhead.</para>
        </listitem>

        <listitem>
          <para><literal role="class">SimilarityMatrixBuilder</literal>
          abstracts building similarity matrices. It exposes <literal
          role="method">put</literal> methods for putting similarities in the
          matrix and a <literal role="class">build</literal> method that
          compiles the accumulated similarities into an (usually truncated)
          immutable matrix. The similarity matrix builder itself is split into
          multiple stages:</para>

          <orderedlist>
            <listitem>
              <para>Use a <literal
              role="class">SimilarityMatrixBuilderFactory</literal> to get a
              <literal role="class">SimilarityMatrixBuilder</literal> that
              will build a matrix for a given number of rows. This is
              necessary so the matrix builder can know the matrix size ahead
              of time.</para>
            </listitem>

            <listitem>
              <para>Accumulate similarities in the <literal
              role="class">SimilarityMatrixBuilder</literal>.</para>
            </listitem>

            <listitem>
              <para>Call the matrix builder's build() method to get a <literal
              role="class">SimilarityMatrix</literal>.</para>
            </listitem>
          </orderedlist>

          <para>The default (and currently only) implementation of the
          similarity matrix framework is TruncatingSimilarityMatrixBuilder,
          which accumulates and maintains the truncated rows of the similarity
          matrix in priority queues. For a neighborhood size N, the matrix
          builder only ever keeps the N most similar neighbors of each item in
          memory.</para>
        </listitem>
      </itemizedlist>

      <para>This level of division and declarative dependency structure allows
      the item-item recommender to be extensively reconfigured and customized.
      It should therefore be fairly easy to plug a new piece into it to test
      new recommender ideas.</para>
    </section>
  </section>
</article>
